\documentclass{article}

\author{Aidan Ewart}
\title{A Recipie for Induction}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{syntax}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{xcolor}

\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}

\addbibresource{ind.bib}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}

\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\definecolor{darkgreen}{HTML}{006400}
\definecolor{jade}{HTML}{00A86B}
\definecolor{maroon}{HTML}{800000}

\lstdefinelanguage{att}
{
keywords=[1]{Definition,Axiom,Reduction},
keywords=[2]{Check,Compute,Print},
keywords=[3]{forall,fun,Type},
literate={->}{{$\to$}}1 {=>}{{$\Rightarrow$}}1,
sensitive=true,
morecomment=[s]{\(*}{*\)},
keywordstyle=[1]{\bfseries \color{blue}},
keywordstyle=[2]{\bfseries \color{orange}},
keywordstyle=[3]{\bfseries \color{jade}},
commentstyle={\itshape \color{darkgreen}},
breaklines=true,
basicstyle=\ttfamily
}

\lstset{
language=att
}

\newcommand{\set}{\mathcal{U}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\fin}{\mathbb{F}}
\newcommand{\elim}{\mathrm{elim}}
\newcommand{\rec}{\mathrm{rec}}
\newcommand{\tx}[1]{\mathrm{#1}}

\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\for}[2]{\Pi_{#1}#2}

\newcommand{\bnfdef}{\hspace{0.5cm} ::= \hspace{0.5cm}}
\newcommand{\alt}{\hspace{0.25cm} | \hspace{0.25cm}}

\newcommand{\bb}{\mathbf}
\newcommand{\evals}{\rightsquigarrow^{nf}}

\begin{document}
\maketitle

In this document I present some observations and results gained while trying to implement induction in a \emph{minimal} type theory.

\section{A (minimal) Type Theory}
In this section I present the syntax, big-step semantics, and typing rules of a minimal type theory ATT, which I will use as a basis to extend with more axioms. 

\begin{align*}
    s \bnfdef& \set_n, n \in \nat
    \\
    \bb{T} \bnfdef& \fun{v:\bb{T}}{\bb{T}} \alt \for{v : \bb{T}}{\bb{T}} \alt s \alt \bb{T T} \alt \bb{T} : \bb{T} \alt v
\end{align*}

\subsection{Typechecking and Evaluation Rules}

\begin{mathpar}
    \infer
        {v : \tau \in \Gamma}
        {\Gamma \vdash v : \tau}
    \and \infer
        {i > j}
        {\Gamma \vdash \set_j : \set_i}
    \and \infer
        {\Gamma \vdash \tau : \set_i
        \\ \Gamma \vdash \tau \evals \tau'
        \\ \Gamma \vdash e : \tau'}
        {\Gamma \vdash e : \tau : \tau'}
    \and \infer
        {\Gamma \vdash \tau : \set_i
        \\ \Gamma \vdash \tau \evals \tau'
        \\ \Gamma, v : \tau' \vdash e : \upsilon}
        {\Gamma \vdash \fun{v: \tau}{e} : \upsilon}
    \and \infer
        {\Gamma \vdash \tau : \set_i
        \\ \Gamma \vdash \tau \evals \tau'
        \\ \Gamma, v : \tau' \vdash e : \set_j
        \\ k \ge i, j}
        {\Gamma \vdash \for{v: \tau}{e} : \set_k}
    \and \infer
        {\Gamma \vdash f : \for{v:\tau}{e}
        \\ \Gamma \vdash x : \upsilon
        \\ \Gamma \vdash x \evals x'
        \\ \Gamma \vdash \upsilon \subseteq \tau}
        {\Gamma \vdash f x : e[v \mapsto x']}
    \and \infer
        {\Gamma \vdash e : \tau
        \\ \Gamma \vdash \tau \subseteq \upsilon}
        {\Gamma \vdash e : \upsilon}
    \and \infer
        {i \geq j}
        {\Gamma \vdash \set_j \subseteq \set_j}
    \and \infer
        {\Gamma \vdash \tau_0 \subseteq \tau_1
        \\ \Gamma \vdash \upsilon_0 \subseteq \upsilon_1}
        {\Gamma \vdash \for{v: \tau_0}{\upsilon_0} \subseteq \for{u: \tau_1}{\upsilon_1}}
    \and \infer
        {\Gamma \vdash \tau_0 \subseteq \tau_1
        \\ \Gamma \vdash \upsilon_0 \subseteq \upsilon_1}
        {\Gamma \vdash \fun{v: \tau_0}{\upsilon_0} \subseteq \fun{u: \tau_1}{\upsilon_1}}
    \and \infer
        {\Gamma \vdash \tau_0 \subseteq \tau_1
        \\ \Gamma \vdash \upsilon_0 \subseteq \upsilon_1}
        {\Gamma \vdash \tau_0 \upsilon_0 \subseteq \tau_1 \upsilon_1}
    \and \infer
        {\Gamma \vdash v = u}
        {\Gamma \vdash v \subseteq u}
    \and \infer
        { }{\Gamma \vdash v \evals v}
    \and \infer
        { }{\Gamma \vdash \set_i \evals \set_i}
    \and \infer
        {\Gamma \vdash f \evals \fun{v}{e}
        \\ \Gamma \vdash x \evals x'
        \\ \Gamma \vdash e[v \mapsto x'] \evals t}
        {\Gamma \vdash f x \evals t}
    \and \infer
        {\Gamma \vdash e \evals e'}
        {\Gamma \vdash e : \tau \evals e'}
    \and \infer
        {\Gamma \vdash e \evals e'}
        {\Gamma \vdash \fun{v : \tau}{e} \evals \fun{v}{e'}}
    \and \infer
        {\Gamma \vdash e \evals e'
        \\ \Gamma \vdash \tau \evals \tau'}
        {\Gamma \vdash \for{v : \tau}{e} \evals \for{v : \tau'}{e'}}
\end{mathpar}

\subsection{The Type $\W$ of Well-Founded Trees}

This is the $\W$ axiom for well-founded trees as proposed by Martin-L{\"o}f\cite{MLTT:1}:

\begin{mathpar}
    \infer
        {\Gamma \vdash S : \set
        \\ \Gamma \vdash P : S \to \set}
        {\Gamma \vdash \W(S,P) : \set}
    \and \infer
        {\Gamma \vdash s : S
        \\ \Gamma \vdash p : P s \to \W(S,P)}
        {\Gamma \vdash \sup(s,p) : \W(S,P)}
    \and \infer
        {\Gamma \vdash w : \W(S,P)
        \\ \Gamma \vdash S : \set
        \\ \Gamma \vdash P : S \to \set
        \\ \Gamma \vdash C : \W(S,P) \to \set{x}
        \\ \Gamma \vdash \Upsilon : \for{s: S}{[\for{f:P s \to \W(S,P)}{\for{p: P s}{C (f p) \to C \sup(s,f)}}]} \to \for{x: \W(S,P)}{C x}}
        {\Gamma \vdash \rec(w,\Upsilon) : C w}
    \and \infer
        {\Gamma \vdash \Upsilon x u (\fun{y}{\rec(u y,c)}) \evals e}
        {\Gamma \vdash \rec(\sup(x,u),\Upsilon) \evals e}
\end{mathpar}

Unfortunately, the $\W$-type fails to be useful in practice without a degree of extensionality\cite{OTT:1}, which may be undesirable. To this end, I formuate an alternative representation of $\W$-types appropriate for intensional type theories, such as ATT.

\subsection{The Type $\V$ of Well-Formed Trees}

\subsubsection{Naturals, Bounded Naturals, and Vectors}

These axioms just contain the usual definitions of $\nat$ and $n$-bounded naturals $\fin_n$ with recursive eliminators. I also add $n$-ary tuple types, $T^n$ - this can be implemented using $\Sigma$-types and $\rec_\nat$, but I include it axiomatically for simplicity.

\begin{mathpar}
    \infer
        { }
        {\Gamma \vdash \nat : \set_n}
    \and \infer
        {\Gamma \vdash n : \nat}
        {\Gamma \vdash S n : \nat}
    \and \infer
        { }
        {\Gamma \vdash Z : \nat}
    \and \infer
        {\Gamma \vdash n : \nat}
        {\Gamma \vdash \fin_n : \set}
    \and \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash m : \fin_n}
        {\Gamma \vdash S_n m : \fin_{S n}}
    \and \infer
        {\Gamma \vdash n : \nat}
        {\Gamma \vdash Z_n : \fin_{S n}}
    \and \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash T : \set}
        {\Gamma \vdash T^n : \set}
    \and \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash T : \set
        \\ \Gamma \vdash t : T
        \\ \Gamma \vdash v : T^n}
        {\Gamma \vdash \tx{cons}(T,n,t,v) : T^{S n}}
    \and \infer
        {\Gamma \vdash T : \set}
        {\Gamma \vdash \tx{unit}(T) : T^Z}
    \and \infer
        {\Gamma \vdash P : \nat \to \set_n
        \\ \Gamma \vdash z : P Z
        \\ \Gamma \vdash s : \for{n : \nat}{P n \to P (S n)}
        \\ \Gamma \vdash n : \nat}
        {\Gamma \vdash \rec_\nat(P,z,s,n) : P n}
    \and \infer
        {\Gamma \vdash P : \for{n: \nat}{\fin_n \to \set}
        \\ \Gamma \vdash z : \for{n: \nat}{P (S n) Z_n}
        \\ \Gamma \vdash s : \for{n: \nat}{\for{f : \fin_n}{P n f \to P (S n) (S_n f)}}
        \\ \Gamma \vdash n : \nat \\ \Gamma \vdash f : \fin_n}
        {\Gamma \vdash \rec_\fin(n,P,z,s,f) : P n f}
    \and \infer
        {\Gamma \vdash T : \set
        \\ \Gamma \vdash P : \for{n: \nat}{T^n \to \set}
        \\ \Gamma \vdash z : P Z (\tx{unit}(T))
        \\ \Gamma \vdash s : \for{n: \nat}{\for{v : T^n}{\for{t: T}{P n v \to P (S n) (\tx{cons}(T,S n,t,v)}}}
        \\ \Gamma \vdash n : \nat \\ \Gamma \vdash v : T^n}
        {\Gamma \vdash \rec_{T^n}(P,z,s,v) : P n v}
    \and \infer
        {\Gamma \vdash z \evals z'}
        {\Gamma \vdash \rec_\nat(P,z,s,Z) \evals z'}
    \and \infer
        {\Gamma \vdash s (\rec_\nat(P,z,s,n)) \evals p}
        {\Gamma \vdash \rec_\nat(P,z,s,S n) \evals p}
    \and \infer
        {\Gamma \vdash z n \evals z'}
        {\Gamma \vdash \rec_\fin(S n,P,z,s,Z_n) \evals z'}
    \and \infer
        {\Gamma \vdash s n (\rec_\fin(n,P,z,s,f)) \evals p}
        {\Gamma \vdash \rec_\fin(S n,P,z,s,S_n f) \evals p}
    \and \infer
        {\Gamma \vdash z \evals z'}
        {\Gamma \vdash \rec_{T^Z}(P,z,s,\tx{unit}(T)) \evals z'}
    \and \infer
        {\Gamma \vdash s n v t (\rec_{T^n}(P,z,s,v)) \evals z'}
        {\Gamma \vdash \rec_{T^{S n}}(P,z,s,\tx{cons}(T,n,t,v)) \evals z'}
\end{mathpar}

I now define the usual $\Sigma$-types (existential quantifiers), which are needed for the definition of $\V$:

\begin{mathpar}
    \infer
        {\Gamma \vdash A : \set
        \\ \Gamma \vdash B : A \to \set}
        {\Gamma \vdash \Sigma(A,B) : \set}
    \and \infer
        {\Gamma \vdash A : \set
        \\ \Gamma \vdash B : A \to \set
        \\ \Gamma \vdash a : A
        \\ \Gamma \vdash p : B a}
        {\Gamma \vdash \exists(A,B,a,p) : \Sigma(A,B)}
    \and \infer
        {\Gamma \vdash A : \set
        \\ \Gamma \vdash B : A \to \set
        \\ \Gamma \vdash P : \Sigma(A,B) \to \set
        \\ \Gamma \vdash f : \for{x: A}{\for{p: B a}{P \exists(A,B,x,p)}}
        \\ \Gamma \vdash p : \Sigma(A,B)}
        {\Gamma \vdash \elim_\Sigma(A,B,f,p) : P p}
    \and \infer
        {\Gamma \vdash f a b \evals e}
        {\Gamma \vdash \elim_\Sigma(A,B,f,\exists(a,b)) \evals e}
\end{mathpar}

\subsubsection{$\V$}

$\V(n,R)$ is the type of well-founded trees with nodes labelled by $\fin_n$ (i.e. it has $n$ constructors), where each node is the supremum of $R x$ subtrees, where $x: \fin_n$. This can be formulated axiomatically as follows:

\begin{mathpar}
    \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash R : \fin_n \to \nat}
        {\Gamma \vdash V(n,R) : \set}
\end{mathpar}

$\tx{sup}(n,R,x,t)$ is the $x$th constructor for $\V(n,R)$, and is the supremum of the subtrees $t$:

\begin{mathpar}
    \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash R : \fin_n \to \nat
        \\ \Gamma \vdash c : \fin_n
        \\ \Gamma \vdash t : \V(n,R)^{R c}}
        {\Gamma \vdash \tx{sup}(n,R,c,t) : \V(n,R)}
\end{mathpar}

In order to do inductive proofs of some property $P: \V(n,R) \to \set$ on some $\tx{sup}(n,R,c,t)$, we need to know that every subtree in $t$ also satisfies $P$, i.e. for every $x$ in $t$ there exists a proof of $Px$; using $\Sigma$ types, this requirement can be encoded as $\Sigma(\V(n,R),P)^{R c}$.

Given the ability to `map' over an $n$-ary product, and extract the first element of a $\Sigma$-type,

\begin{align*}
    \tx{map} :=& \fun{A: \set}{\fun{B: \set}{\fun{f: A \to B}{\fun{n: \nat}{\fun{v: A^n}{
    \\ &\rec_{A^n}(\fun{m}\fun{x}{{B^m}},\tx{unit}(t),\fun{n}{\fun{x}{\fun{t}{\fun{v}{{cons(B,n,v,(f t))}}}}},v) : B^n}}}}}
    \\ \tx{fst} :=& \fun{A: \set}{\fun{B: A \to \set}{\fun{p: \Sigma(A,B)}{\elim_\Sigma(A,B,\fun{a}{\fun{b}{a}},p)}}}
\end{align*}

the recursor for $\V(n,R)$ becomes obvious, if verbose:

\begin{mathpar}
    \infer
        {\Gamma \vdash n : \nat
        \\ \Gamma \vdash R : \fin_n
        \\ \Gamma \vdash P : \V(n,R) \to \set
        \\ \Gamma \vdash f : \for{c: \fin_n}{\for{s: \Sigma(\V(n,R),P)^{R c}}{P \tx{sup}(n,R,c,
            \tx{map}(\Sigma(\V(n,R),P))(\V(n,R))(\tx{fst}(\V(n,R))P)(R c)s)}}
        \\ \Gamma \vdash t : \V(n,R)}
        {\Gamma \vdash \rec_\V(n,R,P,f,t) : P t}
    \and \infer
        {\Gamma \vdash f c (\tx{map}(\V(n,R))(\Sigma(\V(n,R),P))(\fun{t: \V(n,R)}{\exists(t,\rec_\V(n,R,P,f,t))})(R c)t) \evals e}
        {\Gamma \vdash \rec_\V(n,R,P,f,\tx{sup}(n,R,c,t)) \evals e}
\end{mathpar}

\printbibliography

\end{document}